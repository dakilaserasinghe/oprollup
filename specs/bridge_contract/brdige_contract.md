# The Bridge Contract
The bridge contract is responsible to act as the middle layer in a Rollup between
Layer-1 and Layer-2. It facilitates user entrance and exit of rollup supporting asset
transfers between layers. The integrity and security of the Rollup is held up by the
bridge contract.

A bridge contract has several roles in a simple payment system. It should accept
deposits from the users and allow users to exit from the Rollup. It should perform as
a “messenger ” between Layer-1 and Layer-2. And finally the bridge contract operate
as the final referee in case of a dispute over a fraudulent batch submission.
In the following subsections we describe our approach in accomplishing 
aforementioned properties of a Rollup bridge contract.

## Protocol Assumptions of the Layer-1 Blockchain
In designing a bridge contract, we rely on several assumptions that are made on the
underlying blockchain.

- **Neutrality** : Validators of the underlying blockchain are not colluding with
the Rollup operators. Currently, Layer-1 blockchains are fairly decentralized
networks, where colluding is extremely difficult. Hence it is correct to assume
strong neutrality from Ethereum.
- **Eventual Delivery** : A user transaction will be minted in the underlying
blockchain given that he pays an appropriate base fee. Ethereum operates on
an economic-incentive gas fee mechanism, ensuring that the transaction will
eventually be added to an upcoming block.
- **Safety of Smart Contract** : A smart contract is considered as a trustless
immutable third party. It is a deterministic decentralized program which carries
the same security as Ethereum. This enables a trust-minimized bridge creation
for Layer-2.

# User Entrance and Exit
The user entry to the Rollup is supported by “l1deposit” shown in figure 17. Here
bridge contract emit an event indicating a valid fund deposit in Layer-1. User exit is
not trivial as entrance. It consists of two transactions in Layer-2 and Layer-1 initiated
in the given order (see figure 18). The high level view of the mechanism is discussed
under Transactions 4.2 section.
The Layer-1 withdrawal transaction, “l1withdraw” is implemented in the bridge
contract. Once after the Layer-2 withdrawal is finalized in Layer-1, users can claim
their funds initiating a withdraw request in bridge contract. This is generated through
the user wallet. Our Layer-1 withdrawal is based on a proof-of-inclusion mechanism.

# Proof of Inclusion
Proof of inclusion (PoI) is the methodology of verifying users have correctly withdrawn
funds in Layer-2 and authorizing bridge contract to release funds back in Layer-1. PoI
includes a proof that verifying the target Layer-2 withdrawal transaction is included
in the corresponding batch.

If the Merkle root generated by the leaf transaction and proof is equal to the
associated transaction root of the batch, the bridge contract can release funds to the
receivers.

# Authentication Process for Layer-1 Withdrawals
Before executing the Proof of Inclusion, a withdrawal transaction should go through
various validation steps. This complete process is illustrated in figure 24.
It should first verify if the Rollup is in a stable state to allow withdrawals. If there
is a dispute over any block in the system, withdrawal transactions will be rejected
until there is a resolution over the canonical chain.

In the next steps, the system will check the status of the batch to determine
whether it has reached hard finality. It will also verify the transaction-level details,
such as whether the claimed withdrawal has already been processed and whether the
transaction is definitely a withdrawal transaction. Finally, the system will authenticate
the proof of inclusion by comparing it against the transaction root.
After all of these checkpoints have passed successfully, the funds will be released to
the owner, confirming the validity of the user’s address.

# State Commitment Chain
The State Commitment Chain (SCC) is the canonical chain which preserves the world
state of the Rollup. This is implemented as an array of structures in Solidity. Each
structure contains the previous state root, the post-state root, the transaction root,
the transaction hash, and the timestamp indicating when the block is expected to
reach hard finality (see listing 1).

Sequencer will append to the SCC by periodically submitting blocks with state
roots and transaction data as Calldata. transaction hash is calculated on chain using
keccak256 hash function and this will facilitate to authenticate transaction data when
a verifier challenges a submitted block. Additionally, append function will only accept
a block if its immediate previous block’s post-state root matches with the pre-state
root of the new block, adhering to a strict chain integrity.

```
    struct stateCommitments {
        bytes32 prevStateRoot;
        bytes32 postStateRoot;
        bytes32 txRoot;
        bytes32 txhash;
        uint256 finality;
    }

    // state commitment chain
    stateCommitments[] scc;
```
<p align="center">Listing 1 : State Commitment Chain</p>

# Streamlining State Commitment Chain Maintenance
One limitation of our implementation is it maintains the complete Layer-2 state within
the Layer-1 bridge contract. As a result, our approach does not strictly constitute a
Layer-2 blockchain but instead involves certain nodes directly interfacing with the
bridge contract to facilitate chain progression.
Due to this approach, we have encountered a situation where a monotonically
increasing canonical chain has been established, resulting in increased 
memory consumption. However in the current Ethreum’s perspective this does not impose any
cost-related implications. But considering the multitude of applications 
being developed on Ethereum, it is reasonable to anticipate that the 
protocol may introduce a new gas scheme specifically tailored for storage.

Looking into the future and to gain rewards from releasing storage in Ethereum,
we have implemented a maintenance mechanism to release matured data from the
canonical Rollup chain (aka SCC). The process is designed in a way it shall not release
any block data unless there is consensus over the canonical chain. The definition
for maturity is three times the challenge period which is set when deploying the
bridge contract. We hold an optimistic assumption that users will have released their
withdrawal within this maturity period.
